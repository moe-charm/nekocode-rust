// C++ Grammar for pest parser
// This grammar defines the parsing rules for detecting C++ classes, functions, namespaces, templates

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment | block_comment }
line_comment = _{ "//" ~ (!"\n" ~ ANY)* }
block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Identifiers
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// String literals
string_literal = _{ raw_string | regular_string }
raw_string = @{ "R\"" ~ delimiter ~ "(" ~ raw_content ~ ")" ~ delimiter ~ "\"" }
delimiter = @{ ASCII_ALPHANUMERIC* }
raw_content = @{ (!")" ~ ANY)* }
regular_string = @{ "\"" ~ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* ~ "\"" }

// Character literal
char_literal = @{ "'" ~ (!("'" | "\\") ~ ANY | "\\" ~ ANY) ~ "'" }

// Keywords
class_keyword = { "class" }
struct_keyword = { "struct" }
namespace_keyword = { "namespace" }
template_keyword = { "template" }
typename_keyword = { "typename" }
virtual_keyword = { "virtual" }
public_keyword = { "public" }
private_keyword = { "private" }
protected_keyword = { "protected" }
static_keyword = { "static" }
const_keyword = { "const" }
constexpr_keyword = { "constexpr" }
inline_keyword = { "inline" }
extern_keyword = { "extern" }
using_keyword = { "using" }
typedef_keyword = { "typedef" }
if_keyword = { "if" }
else_keyword = { "else" }
for_keyword = { "for" }
while_keyword = { "while" }
do_keyword = { "do" }
switch_keyword = { "switch" }
case_keyword = { "case" }
default_keyword = { "default" }
try_keyword = { "try" }
catch_keyword = { "catch" }
throw_keyword = { "throw" }
return_keyword = { "return" }

// Preprocessor directives
include_directive = { "#include" ~ (angle_include | quote_include) }
angle_include = { "<" ~ include_path ~ ">" }
quote_include = { "\"" ~ include_path ~ "\"" }
include_path = @{ (!(">" | "\"") ~ ANY)+ }
define_directive = { "#define" ~ identifier ~ macro_body? }
macro_body = @{ (!"\n" ~ ANY)* }

// Access modifiers
access_modifier = { public_keyword | private_keyword | protected_keyword }

// Template parameters
template_params = { "<" ~ template_param_list ~ ">" }
template_param_list = { template_param ~ ("," ~ template_param)* }
template_param = { 
    (typename_keyword | class_keyword) ~ identifier |
    identifier ~ identifier ~ ("=" ~ default_value)? |
    template_keyword ~ template_params ~ class_keyword ~ identifier
}

// Function parameters
parameter_list = { "(" ~ (parameter ~ ("," ~ parameter)*)? ~ ")" }
parameter = { 
    type_spec ~ identifier? ~ ("=" ~ default_value)? |
    "..." // variadic
}
type_spec = { 
    const_keyword? ~ 
    (identifier ~ "::")* ~ 
    identifier ~ 
    template_args? ~ 
    ("*" | "&" | "&&")* ~ 
    const_keyword?
}
template_args = { "<" ~ type_list ~ ">" }
type_list = { type_spec ~ ("," ~ type_spec)* }
default_value = { identifier | string_literal | char_literal | number | "nullptr" | "true" | "false" }
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ ("f" | "F" | "l" | "L" | "u" | "U")? }

// Inheritance
inheritance = { ":" ~ access_modifier? ~ virtual_keyword? ~ inheritance_list }
inheritance_list = { base_class ~ ("," ~ access_modifier? ~ virtual_keyword? ~ base_class)* }
base_class = { (identifier ~ "::")* ~ identifier ~ template_args? }

// Namespace scope
scope_resolution = { "::" }

// Function declaration/definition
function_decl = { 
    template_params? ~
    virtual_keyword? ~
    static_keyword? ~
    inline_keyword? ~
    constexpr_keyword? ~
    type_spec ~
    (identifier ~ "::")* ~
    identifier ~
    parameter_list ~
    const_keyword? ~
    ("override" | "final")? ~
    ("=" ~ ("0" | "delete" | "default"))? ~
    (function_body | ";")
}

function_body = { "{" ~ function_content ~ "}" }
function_content = { (!("}" | "{") ~ ANY | "{" ~ function_content ~ "}")* }

// Constructor/destructor
constructor_decl = {
    explicit_keyword? ~
    identifier ~
    parameter_list ~
    initializer_list? ~
    (function_body | ";")
}
destructor_decl = {
    virtual_keyword? ~
    "~" ~
    identifier ~
    parameter_list ~
    ("override" | "final")? ~
    ("=" ~ ("0" | "delete" | "default"))? ~
    (function_body | ";")
}
explicit_keyword = { "explicit" }
initializer_list = { ":" ~ initializer ~ ("," ~ initializer)* }
initializer = { identifier ~ "(" ~ argument_list? ~ ")" }

// Class/struct definition
class_def = { 
    template_params? ~
    (class_keyword | struct_keyword) ~
    identifier ~
    inheritance? ~
    class_body
}

class_body = { "{" ~ class_member* ~ "}" ~ ";"? }
class_member = _{ 
    access_modifier ~ ":" |
    function_decl |
    constructor_decl |
    destructor_decl |
    variable_decl |
    using_decl |
    typedef_decl |
    class_def |
    ANY
}

// Variable declaration
variable_decl = { 
    static_keyword? ~
    const_keyword? ~
    type_spec ~
    variable_list ~
    ";"
}
variable_list = { variable_item ~ ("," ~ variable_item)* }
variable_item = { identifier ~ ("=" ~ initializer_expr)? }
initializer_expr = { expression | "{" ~ expression_list? ~ "}" }

// Expression (simplified)
expression = { 
    identifier |
    string_literal |
    char_literal |
    number |
    "(" ~ expression ~ ")" |
    expression ~ binary_op ~ expression |
    unary_op ~ expression
}
expression_list = { expression ~ ("," ~ expression)* }
binary_op = { "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "&&" | "||" }
unary_op = { "!" | "-" | "+" | "++" | "--" | "*" | "&" }

// Namespace definition
namespace_def = { 
    namespace_keyword ~ 
    identifier? ~ 
    namespace_body 
}
namespace_body = { "{" ~ namespace_content* ~ "}" }
namespace_content = _{ 
    function_decl |
    class_def |
    namespace_def |
    variable_decl |
    using_decl |
    typedef_decl |
    include_directive |
    ANY
}

// Using declarations
using_decl = { 
    using_keyword ~ 
    (namespace_keyword ~ (identifier ~ "::")* ~ identifier | 
     identifier ~ "=" ~ type_spec) ~ 
    ";"
}

// Typedef
typedef_decl = { 
    typedef_keyword ~ 
    type_spec ~ 
    identifier ~ 
    ";"
}

// Function calls
function_call = { 
    (identifier ~ "::")* ~ 
    identifier ~ 
    template_args? ~ 
    "(" ~ 
    argument_list? ~ 
    ")"
}
method_call = { 
    expression ~ 
    ("." | "->") ~ 
    identifier ~ 
    template_args? ~ 
    "(" ~ 
    argument_list? ~ 
    ")"
}
argument_list = { expression ~ ("," ~ expression)* }

// Control flow statements (for complexity)
if_stmt = { if_keyword ~ "(" ~ expression ~ ")" ~ statement }
else_stmt = { else_keyword ~ statement }
for_stmt = { for_keyword ~ "(" ~ for_init? ~ ";" ~ expression? ~ ";" ~ expression? ~ ")" ~ statement }
while_stmt = { while_keyword ~ "(" ~ expression ~ ")" ~ statement }
do_while_stmt = { do_keyword ~ statement ~ while_keyword ~ "(" ~ expression ~ ")" ~ ";" }
switch_stmt = { switch_keyword ~ "(" ~ expression ~ ")" ~ "{" ~ switch_case* ~ "}" }
try_stmt = { try_keyword ~ statement ~ catch_clause* }
catch_clause = { catch_keyword ~ "(" ~ parameter ~ ")" ~ statement }
switch_case = { (case_keyword ~ expression | default_keyword) ~ ":" ~ statement* }
for_init = { variable_decl | expression }

// Statements
statement = _{ 
    compound_stmt |
    if_stmt |
    else_stmt |
    for_stmt |
    while_stmt |
    do_while_stmt |
    switch_stmt |
    try_stmt |
    function_call ~ ";" |
    method_call ~ ";" |
    variable_decl |
    expression ~ ";" |
    ";"
}
compound_stmt = { "{" ~ statement* ~ "}" }

// Main program structure
top_level = _{ 
    include_directive |
    define_directive |
    namespace_def |
    class_def |
    function_decl |
    variable_decl |
    using_decl |
    typedef_decl |
    template_params ~ (class_def | function_decl) |
    ANY
}

program = { SOI ~ top_level* ~ EOI }