// C# Grammar for pest parser
// This grammar defines the parsing rules for detecting C# classes, methods, interfaces, properties

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment | block_comment }
line_comment = _{ "//" ~ (!"\n" ~ ANY)* }
block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Identifiers
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// String literals
string_literal = _{ verbatim_string | interpolated_string | regular_string }
verbatim_string = @{ "@\"" ~ (!"\"" ~ ANY | "\"\"")* ~ "\"" }
interpolated_string = @{ "$\"" ~ (!("\"" | "{") ~ ANY | "{" ~ (!("}" | "\"") ~ ANY)* ~ "}")* ~ "\"" }
regular_string = @{ "\"" ~ (!("\"" | "\\") ~ ANY | "\\" ~ ANY)* ~ "\"" }

// Character literal
char_literal = @{ "'" ~ (!("'" | "\\") ~ ANY | "\\" ~ ANY) ~ "'" }

// Keywords
class_keyword = { "class" }
interface_keyword = { "interface" }
struct_keyword = { "struct" }
enum_keyword = { "enum" }
namespace_keyword = { "namespace" }
using_keyword = { "using" }
public_keyword = { "public" }
private_keyword = { "private" }
protected_keyword = { "protected" }
internal_keyword = { "internal" }
static_keyword = { "static" }
virtual_keyword = { "virtual" }
override_keyword = { "override" }
abstract_keyword = { "abstract" }
sealed_keyword = { "sealed" }
partial_keyword = { "partial" }
async_keyword = { "async" }
await_keyword = { "await" }
get_keyword = { "get" }
set_keyword = { "set" }
if_keyword = { "if" }
else_keyword = { "else" }
for_keyword = { "for" }
foreach_keyword = { "foreach" }
while_keyword = { "while" }
do_keyword = { "do" }
switch_keyword = { "switch" }
case_keyword = { "case" }
default_keyword = { "default" }
try_keyword = { "try" }
catch_keyword = { "catch" }
finally_keyword = { "finally" }
throw_keyword = { "throw" }
return_keyword = { "return" }
yield_keyword = { "yield" }
where_keyword = { "where" }
from_keyword = { "from" }
select_keyword = { "select" }
orderby_keyword = { "orderby" }
group_keyword = { "group" }
join_keyword = { "join" }
into_keyword = { "into" }
let_keyword = { "let" }

// Access modifiers
access_modifier = { public_keyword | private_keyword | protected_keyword | internal_keyword }

// Generic parameters
generic_params = { "<" ~ generic_param_list ~ ">" }
generic_param_list = { generic_param ~ ("," ~ generic_param)* }
generic_param = { identifier ~ (where_keyword ~ generic_constraint)? }
generic_constraint = { identifier | class_keyword | struct_keyword | "new()" }

// Type specifications
type_spec = { 
    identifier ~ 
    generic_args? ~ 
    ("[]" | "?" | "*")* 
}
generic_args = { "<" ~ type_list ~ ">" }
type_list = { type_spec ~ ("," ~ type_spec)* }

// Parameter lists
parameter_list = { "(" ~ (parameter ~ ("," ~ parameter)*)? ~ ")" }
parameter = { 
    ("ref" | "out" | "in" | "params")? ~ 
    type_spec ~ 
    identifier ~ 
    ("=" ~ default_value)?
}
default_value = { string_literal | char_literal | number | "null" | "true" | "false" | identifier }
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ ("f" | "F" | "d" | "D" | "m" | "M")? }

// Inheritance and interfaces
inheritance = { ":" ~ inheritance_list }
inheritance_list = { type_spec ~ ("," ~ type_spec)* }

// Using statements
using_stmt = { using_keyword ~ (identifier ~ "=")? ~ namespace_path ~ ";" }
namespace_path = { identifier ~ ("." ~ identifier)* }

// Namespace definition
namespace_def = { namespace_keyword ~ namespace_path ~ namespace_body }
namespace_body = { "{" ~ namespace_member* ~ "}" }
namespace_member = _{ 
    class_def | 
    interface_def | 
    struct_def | 
    enum_def | 
    using_stmt | 
    ANY 
}

// Class definition
class_def = { 
    attribute_list? ~
    access_modifier? ~
    (static_keyword | abstract_keyword | sealed_keyword | partial_keyword)* ~
    class_keyword ~
    identifier ~
    generic_params? ~
    inheritance? ~
    generic_constraints? ~
    class_body
}

class_body = { "{" ~ class_member* ~ "}" }
class_member = _{ 
    field_def |
    property_def |
    method_def |
    constructor_def |
    destructor_def |
    event_def |
    indexer_def |
    class_def |
    interface_def |
    struct_def |
    enum_def |
    ANY
}

// Interface definition
interface_def = {
    attribute_list? ~
    access_modifier? ~
    partial_keyword? ~
    interface_keyword ~
    identifier ~
    generic_params? ~
    inheritance? ~
    generic_constraints? ~
    interface_body
}

interface_body = { "{" ~ interface_member* ~ "}" }
interface_member = _{ 
    method_signature |
    property_signature |
    event_signature |
    indexer_signature |
    ANY
}

// Method definition
method_def = {
    attribute_list? ~
    access_modifier? ~
    (static_keyword | virtual_keyword | override_keyword | abstract_keyword | sealed_keyword | async_keyword)* ~
    type_spec ~
    identifier ~
    generic_params? ~
    parameter_list ~
    generic_constraints? ~
    (method_body | ";")
}

method_signature = {
    attribute_list? ~
    type_spec ~
    identifier ~
    generic_params? ~
    parameter_list ~
    generic_constraints? ~
    ";"
}

method_body = { "{" ~ method_content ~ "}" }
method_content = { (!("}" | "{") ~ ANY | "{" ~ method_content ~ "}")* }

// Constructor definition
constructor_def = {
    attribute_list? ~
    access_modifier? ~
    static_keyword? ~
    identifier ~
    parameter_list ~
    base_initializer? ~
    (method_body | ";")
}

// Destructor definition
destructor_def = {
    attribute_list? ~
    access_modifier? ~
    "~" ~
    identifier ~
    parameter_list ~
    method_body
}

// Property definition
property_def = {
    attribute_list? ~
    access_modifier? ~
    (static_keyword | virtual_keyword | override_keyword | abstract_keyword)* ~
    type_spec ~
    identifier ~
    property_body
}

property_body = { "{" ~ accessor* ~ "}" }
accessor = { 
    attribute_list? ~
    access_modifier? ~
    (get_keyword | set_keyword) ~
    (accessor_body | ";")
}
accessor_body = { "{" ~ method_content ~ "}" }

property_signature = {
    attribute_list? ~
    type_spec ~
    identifier ~
    "{" ~ (get_keyword | set_keyword) ~ ";" ~ "}"
}

// Field definition
field_def = {
    attribute_list? ~
    access_modifier? ~
    (static_keyword | readonly_keyword | const_keyword)* ~
    type_spec ~
    variable_list ~
    ";"
}

variable_list = { variable_item ~ ("," ~ variable_item)* }
variable_item = { identifier ~ ("=" ~ initializer_expr)? }
initializer_expr = { expression | array_initializer | object_initializer }
array_initializer = { "{" ~ expression_list? ~ "}" }
object_initializer = { "{" ~ property_initializer_list? ~ "}" }
property_initializer_list = { property_initializer ~ ("," ~ property_initializer)* }
property_initializer = { identifier ~ "=" ~ expression }

// Event definition
event_def = {
    attribute_list? ~
    access_modifier? ~
    static_keyword? ~
    "event" ~
    type_spec ~
    identifier ~
    ("=" ~ expression)? ~
    ";"
}

event_signature = {
    attribute_list? ~
    "event" ~
    type_spec ~
    identifier ~
    ";"
}

// Indexer definition
indexer_def = {
    attribute_list? ~
    access_modifier? ~
    (virtual_keyword | override_keyword | abstract_keyword)* ~
    type_spec ~
    "this" ~
    "[" ~ parameter_list ~ "]" ~
    property_body
}

indexer_signature = {
    attribute_list? ~
    type_spec ~
    "this" ~
    "[" ~ parameter_list ~ "]" ~
    "{" ~ (get_keyword | set_keyword) ~ ";" ~ "}"
}

// Struct definition
struct_def = {
    attribute_list? ~
    access_modifier? ~
    partial_keyword? ~
    struct_keyword ~
    identifier ~
    generic_params? ~
    inheritance? ~
    generic_constraints? ~
    struct_body
}

struct_body = { "{" ~ struct_member* ~ "}" }
struct_member = _{ 
    field_def |
    property_def |
    method_def |
    constructor_def |
    event_def |
    indexer_def |
    class_def |
    interface_def |
    struct_def |
    enum_def |
    ANY
}

// Enum definition
enum_def = {
    attribute_list? ~
    access_modifier? ~
    enum_keyword ~
    identifier ~
    (":" ~ type_spec)? ~
    enum_body
}

enum_body = { "{" ~ enum_member_list? ~ "}" }
enum_member_list = { enum_member ~ ("," ~ enum_member)* ~ ","? }
enum_member = {
    attribute_list? ~
    identifier ~
    ("=" ~ expression)?
}

// Attributes
attribute_list = { "[" ~ attribute ~ ("," ~ attribute)* ~ "]" }
attribute = { identifier ~ ("(" ~ attribute_args? ~ ")")? }
attribute_args = { expression ~ ("," ~ expression)* }

// Generic constraints
generic_constraints = { where_clause+ }
where_clause = { where_keyword ~ identifier ~ ":" ~ constraint_list }
constraint_list = { constraint ~ ("," ~ constraint)* }
constraint = { type_spec | class_keyword | struct_keyword | "new()" }

// Base initializer
base_initializer = { ":" ~ ("base" | "this") ~ "(" ~ argument_list? ~ ")" }

// Expressions (simplified)
expression = { 
    string_literal |
    char_literal |
    number |
    identifier |
    "null" |
    "true" |
    "false" |
    "(" ~ expression ~ ")" |
    expression ~ binary_op ~ expression |
    unary_op ~ expression |
    method_call |
    property_access |
    array_access |
    linq_query
}

expression_list = { expression ~ ("," ~ expression)* }
binary_op = { "+" | "-" | "*" | "/" | "%" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "&&" | "||" | "??" }
unary_op = { "!" | "-" | "+" | "++" | "--" | "~" }

// Method calls
method_call = { 
    (identifier ~ ".")* ~ 
    identifier ~ 
    generic_args? ~ 
    "(" ~ 
    argument_list? ~ 
    ")"
}

property_access = { expression ~ "." ~ identifier }
array_access = { expression ~ "[" ~ expression_list ~ "]" }
argument_list = { expression ~ ("," ~ expression)* }

// LINQ queries
linq_query = { 
    from_clause ~ 
    query_body
}

from_clause = { from_keyword ~ identifier ~ "in" ~ expression }
query_body = { 
    (join_clause | let_clause | where_clause_linq | orderby_clause)* ~
    select_clause ~
    into_clause?
}

join_clause = { join_keyword ~ identifier ~ "in" ~ expression ~ "on" ~ expression ~ "equals" ~ expression ~ into_clause? }
let_clause = { let_keyword ~ identifier ~ "=" ~ expression }
where_clause_linq = { where_keyword ~ expression }
orderby_clause = { orderby_keyword ~ expression ~ ("ascending" | "descending")? ~ ("," ~ expression ~ ("ascending" | "descending")?)* }
select_clause = { select_keyword ~ expression | group_keyword ~ expression ~ "by" ~ expression }
into_clause = { into_keyword ~ identifier }

// Control flow statements (for complexity)
if_stmt = { if_keyword ~ "(" ~ expression ~ ")" ~ statement }
else_stmt = { else_keyword ~ statement }
for_stmt = { for_keyword ~ "(" ~ for_init? ~ ";" ~ expression? ~ ";" ~ expression? ~ ")" ~ statement }
foreach_stmt = { foreach_keyword ~ "(" ~ type_spec ~ identifier ~ "in" ~ expression ~ ")" ~ statement }
while_stmt = { while_keyword ~ "(" ~ expression ~ ")" ~ statement }
do_while_stmt = { do_keyword ~ statement ~ while_keyword ~ "(" ~ expression ~ ")" ~ ";" }
switch_stmt = { switch_keyword ~ "(" ~ expression ~ ")" ~ "{" ~ switch_section* ~ "}" }
try_stmt = { try_keyword ~ statement ~ (catch_clause* ~ finally_clause? | finally_clause) }
catch_clause = { catch_keyword ~ ("(" ~ type_spec ~ identifier? ~ ")")? ~ statement }
finally_clause = { finally_keyword ~ statement }
switch_section = { switch_label+ ~ statement+ }
switch_label = { case_keyword ~ expression ~ ":" | default_keyword ~ ":" }

// Other keywords
readonly_keyword = { "readonly" }
const_keyword = { "const" }
for_init = { variable_decl | expression_list }
variable_decl = { type_spec ~ variable_list }

// Statements
statement = _{ 
    compound_stmt |
    if_stmt |
    else_stmt |
    for_stmt |
    foreach_stmt |
    while_stmt |
    do_while_stmt |
    switch_stmt |
    try_stmt |
    method_call ~ ";" |
    variable_decl ~ ";" |
    expression ~ ";" |
    ";"
}
compound_stmt = { "{" ~ statement* ~ "}" }

// Main program structure
top_level = _{ 
    using_stmt |
    namespace_def |
    class_def |
    interface_def |
    struct_def |
    enum_def |
    ANY
}

program = { SOI ~ top_level* ~ EOI }